"""
malware_db.py

Final-shape Malware Database utility:
 - Maintains a hash-based malicious signature table
 - Local JSON file in validated path from directory_contract
 - Optional cloud fetch if config.mode='cloud' (using PQC TLS if strict or non-classical)
 - No directory creation
 - SCIF/airgap => no fetch
 - watch-only constraints only matter for scanning? (We don't block load, but watch-only doesn't typically affect read ops)

No references to ephemeral placeholders or future steps.
"""

import os
import json
import hashlib
import logging
import requests
from typing import Dict, Optional

from aepok_sentinel.core.logging_setup import get_logger
from aepok_sentinel.core.config import SentinelConfig
from aepok_sentinel.core.pqc_tls import create_pqc_ssl_context, PQCTlsError
from aepok_sentinel.core.directory_contract import resolve_path

logger = get_logger("malware_db")


class MalwareDatabase:
    """
    Manages a collection of known-malicious signatures (simple hash approach).
    - load_signatures():
        * if scif/airgap => only local
        * if cloud => optionally fetch from config.cloud_malware_url using PQC if needed
    - check_file(filepath) => returns threat name if matched, else None
    """

    def __init__(self, config: SentinelConfig):
        self.config = config
        # We'll call resolve_path to get the local signature file path, ensuring final shape usage.
        # e.g. "malware_signatures.json" in a "signatures" directory if so defined
        # If not defined, fallback to "malware_signatures.json" in the contract, or an explicit override in config?
        self.local_path = resolve_path("signatures", "malware_signatures.json")
        self.hash_db: Dict[str, str] = {}

    def load_signatures(self) -> None:
        """
        Loads signatures from local JSON or cloud. 
        If SCIF/airgap => local only.
        If cloud mode => tries a cloud fetch if config.cloud_malware_url is set,
                         else fallback local.
        If PQC is enforced => we use a custom requests session with PQC SSLContext.
        """
        mode = self.config.mode
        if mode in ("scif", "airgap"):
            logger.debug("SCIF/airgap => no network. Loading local signatures only.")
            self._load_local()
            return

        if mode == "cloud":
            cloud_url = self.config.raw_dict.get("cloud_malware_url", "")
            if cloud_url:
                try:
                    self._fetch_cloud_signatures(cloud_url)
                    logger.info("Fetched malware signatures from cloud: %s", cloud_url)
                    return
                except Exception as e:
                    logger.warning("Cloud fetch failed: %s, falling back to local load.", e)

            # fallback to local
            self._load_local()
            return

        # If mode is something else (demo?), we just load local
        logger.debug("Mode=%s => defaulting to local signature load.", mode)
        self._load_local()

    def check_file(self, filepath: str) -> Optional[str]:
        """
        Returns the known threat name if the file's sha256 is in the DB, else None.
        If the file doesn't exist or hashing fails => returns None.
        """
        if not os.path.isfile(filepath):
            logger.warning("check_file: path does not exist: %s", filepath)
            return None

        try:
            sha_val = self._compute_sha256(filepath)
        except Exception as e:
            logger.warning("Failed to compute hash for %s: %s", filepath, e)
            return None

        return self.hash_db.get(sha_val)

    # --------------------- Private Methods ----------------------

    def _load_local(self) -> None:
        """
        Loads from local JSON file. If missing => empty DB
        Raises MalwareDBError if the JSON is invalid or missing "hashes" dict.
        """
        if not self.local_path.is_file():
            logger.info("No local signature file at %s => empty DB", self.local_path)
            return

        try:
            with open(self.local_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            if not isinstance(data, dict):
                raise ValueError("malware_signatures.json top-level is not a dict.")
            hash_dict = data.get("hashes", {})
            if not isinstance(hash_dict, dict):
                raise ValueError("malware_signatures.json missing 'hashes' dict.")
            self.hash_db = {**hash_dict}
            logger.info("Loaded %d signatures from %s", len(self.hash_db), self.local_path)
        except Exception as e:
            msg = f"Failed to load local signatures from {self.local_path}: {e}"
            logger.error(msg)
            raise MalwareDBError(msg)

    def _fetch_cloud_signatures(self, url: str) -> None:
        """
        Attempt to fetch signature JSON from the given URL using a PQC-hardened session if config requires it.
        JSON schema:
          { "hashes": { "sha256val": "threatName", ... } }
        Raises MalwareDBError on failure.
        """
        sess = self._build_requests_session()
        try:
            resp = sess.get(url, timeout=10)
            if resp.status_code != 200:
                raise MalwareDBError(f"Cloud signature fetch => code {resp.status_code}")
            data = resp.json()
            hash_dict = data.get("hashes", {})
            if not isinstance(hash_dict, dict):
                raise MalwareDBError("Cloud signature JSON missing 'hashes' dict.")
            self.hash_db = {**hash_dict}
        except Exception as e:
            raise MalwareDBError(f"Cloud fetch error: {e}")

    def _build_requests_session(self) -> requests.Session:
        """
        Similar logic to azure_clients, to enforce PQC if config says so.
        If config.tls_mode='classical' and not strict => default session
        Else => attempt PQC. If strict => fail on error, else fallback to default.
        """
        sess = requests.Session()

        if self.config.tls_mode == "classical" and not self.config.strict_transport:
            return sess

        try:
            ssl_ctx = create_pqc_ssl_context(self.config)
        except PQCTlsError as e:
            if self.config.strict_transport:
                raise MalwareDBError(f"strict_transport => PQC context failed: {e}")
            logger.warning("PQC context failed, fallback to default TLS: %s", e)
            return sess

        # attach custom adapter
        from requests.adapters import HTTPAdapter
        from urllib3.poolmanager import PoolManager

        class PQCPoolManager(PoolManager):
            def __init__(self, ssl_context, *args, **kwargs):
                super().__init__(*args, **kwargs)
                self.ssl_context = ssl_context

            def _new_pool(self, scheme, host, port, request_context=None):
                pool = super()._new_pool(scheme, host, port, request_context=request_context)
                if scheme == "https":
                    pool.ssl_context = self.ssl_context
                return pool

        adapter = HTTPAdapter()
        adapter.init_poolmanager = lambda connections, maxsize, block=None, **kw: PQCPoolManager(
            ssl_context=ssl_ctx,
            num_pools=connections,
            maxsize=maxsize,
            block=block
        )
        sess.mount("https://", adapter)
        return sess

    def _compute_sha256(self, filepath: str) -> str:
        sha = hashlib.sha256()
        with open(filepath, "rb") as f:
            for chunk in iter(lambda: f.read(65536), b""):
                sha.update(chunk)
        return sha.hexdigest()


# ------------------------
# Exception Class
# ------------------------

class MalwareDBError(Exception):
    """
    Raised for any local or cloud signature load errors.
    Covers: missing file, malformed JSON, cloud fetch failure,
    schema validation error, or PQC transport failure.
    """
    pass