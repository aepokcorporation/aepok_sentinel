# malware_db.py
"""
Malware Database utility:
 - Maintains a hash-based malicious signature table
 - Local JSON file in the Sentinel runtime directory (resolved via directory_contract)
 - Optional cloud fetch if config.mode='cloud', using PQC TLS if enforced
 - SCIF/airgap => local-only
 - Watch-only mode does not block loading; read operations are unaffected.
"""

import os
import json
import hashlib
import logging
import requests
from typing import Dict, Optional

from aepok_sentinel.core.logging_setup import get_logger
from aepok_sentinel.core.config import SentinelConfig
from aepok_sentinel.core.pqc_tls import create_pqc_ssl_context, PQCTlsError
from aepok_sentinel.core.directory_contract import resolve_path
from aepok_sentinel.core.audit_chain import append_event

logger = get_logger("malware_db")


class MalwareDBError(Exception):
    """
    Raised for local or cloud signature load errors (e.g., missing file, malformed JSON,
    cloud fetch failure, or PQC transport failure).
    """
    pass


class MalwareDatabase:
    """
    Manages a collection of known-malicious signatures (simple hash approach).
      - load_signatures():
          * SCIF/airgap => local only
          * cloud => optionally fetch from config.cloud_malware_url
          * fallback to local if cloud fetch fails
      - check_file(filepath) => returns threat name if matched, else None
    """

    def __init__(self, config: SentinelConfig):
        self.config = config
        self.local_path = resolve_path("signatures", "malware_signatures.json")
        self.hash_db: Dict[str, str] = {}

    def load_signatures(self) -> None:
        """
        Loads signatures from a local file in the runtime directory or from a
        cloud URL if config.mode='cloud' and config.cloud_malware_url is set.
        Respects SCIF/airgap constraints (no fetch) and enforces PQC if needed.
        """
        mode = self.config.mode
        if mode in ("scif", "airgap"):
            logger.debug("SCIF/airgap => loading local signatures only.")
            self._load_local()
            return

        if mode == "cloud":
            cloud_url = self.config.raw_dict.get("cloud_malware_url", "")
            if cloud_url:
                try:
                    self._fetch_cloud_signatures(cloud_url)
                    logger.info("Fetched malware signatures from cloud: %s", cloud_url)
                    return
                except Exception as e:
                    logger.warning("Cloud fetch failed: %s, falling back to local load.", e)

            # fallback to local
            self._load_local()
            return

        # Otherwise (e.g., 'demo'), load local
        logger.debug("Mode=%s => defaulting to local signature load.", mode)
        self._load_local()

    def check_file(self, filepath: str) -> Optional[str]:
        """
        Returns the known threat name if the file's SHA-256 matches an entry in the DB, else None.
        If the file doesn't exist or hashing fails, returns None.
        """
        if not os.path.isfile(filepath):
            logger.warning("check_file: path does not exist: %s", filepath)
            return None

        try:
            sha_val = self._compute_sha256(filepath)
        except Exception as e:
            logger.warning("Failed to compute hash for %s: %s", filepath, e)
            return None

        return self.hash_db.get(sha_val)

    # --------------------- Private Methods ----------------------

    def _load_local(self) -> None:
        """
        Loads from the local JSON file. If missing => empty DB.
        Raises MalwareDBError if the JSON is invalid or lacks a 'hashes' dictionary.
        """
        if not self.local_path.is_file():
            logger.info("No local signature file at %s => empty DB", self.local_path)
            return

        try:
            with open(self.local_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            if not isinstance(data, dict):
                raise ValueError("malware_signatures.json top-level is not a dict.")
            hash_dict = data.get("hashes", {})
            if not isinstance(hash_dict, dict):
                raise ValueError("malware_signatures.json missing 'hashes' dict.")
            self.hash_db = {**hash_dict}
            logger.info("Loaded %d signatures from %s", len(self.hash_db), self.local_path)
        except Exception as e:
            msg = f"Failed to load local signatures from {self.local_path}: {e}"
            logger.error(msg)
            raise MalwareDBError(msg)

    def _fetch_cloud_signatures(self, url: str) -> None:
        """
        Attempts to fetch a signatures JSON from the given URL, using PQC if required.
        Emits MALWARE_DB_FETCHED and MALWARE_DB_VERIFIED events on success.
        """
        sess = self._build_requests_session()
        resp = sess.get(url, timeout=10)
        if resp.status_code != 200:
            raise MalwareDBError(f"Cloud signature fetch => code {resp.status_code}")

        if "application/json" not in resp.headers.get("Content-Type", ""):
            raise MalwareDBError("Cloud signature fetch returned non-JSON content.")

        data = resp.json()
        hash_dict = data.get("hashes", {})
        if not isinstance(hash_dict, dict):
            raise MalwareDBError("Cloud signature JSON missing 'hashes' dict.")
        self.hash_db = {**hash_dict}

        # Log fetch and verification
        append_event("MALWARE_DB_FETCHED", {
            "url": url,
            "status_code": resp.status_code,
            "content_length": len(resp.content)
        })
        append_event("MALWARE_DB_VERIFIED", {
            "url": url,
            "hash_count": len(self.hash_db)
        })

    def _build_requests_session(self) -> requests.Session:
        """
        Builds a requests.Session that enforces PQC if config says so.
        If config.tls_mode='classical' and not strict => normal TLS;
        otherwise => attempt PQC, with strict => fail on error, else fallback.
        """
        sess = requests.Session()

        if self.config.tls_mode == "classical" and not self.config.strict_transport:
            return sess

        try:
            ssl_ctx = create_pqc_ssl_context(self.config)
        except PQCTlsError as e:
            if self.config.strict_transport:
                raise MalwareDBError(f"strict_transport => PQC context failed: {e}")
            logger.warning("PQC context failed, fallback to default TLS: %s", e)
            return sess

        from requests.adapters import HTTPAdapter
        from urllib3.poolmanager import PoolManager

        class PQCPoolManager(PoolManager):
            def __init__(self, ssl_context, *args, **kwargs):
                super().__init__(*args, **kwargs)
                self.ssl_context = ssl_context

            def _new_pool(self, scheme, host, port, request_context=None):
                pool = super()._new_pool(scheme, host, port, request_context=request_context)
                if scheme == "https":
                    pool.ssl_context = self.ssl_context
                return pool

        adapter = HTTPAdapter()
        adapter.init_poolmanager = lambda connections, maxsize, block=None, **kw: PQCPoolManager(
            ssl_context=ssl_ctx,
            num_pools=connections,
            maxsize=maxsize,
            block=block
        )
        sess.mount("https://", adapter)
        return sess

    def _compute_sha256(self, filepath: str) -> str:
        sha = hashlib.sha256()
        with open(filepath, "rb") as f:
            for chunk in iter(lambda: f.read(65536), b""):
                sha.update(chunk)
        return sha.hexdigest()