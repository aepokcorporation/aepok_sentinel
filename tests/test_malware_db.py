"""
Unit tests for aepok_sentinel/utils/malware_db.py

Validates:
- load_signatures() from local
- scif/airgap => no cloud attempt
- cloud => fetch from url or fallback
- check_file => matches known hash
"""

import os
import shutil
import unittest
import tempfile
import json
from unittest.mock import patch, MagicMock

from aepok_sentinel.core.config import SentinelConfig
from aepok_sentinel.utils.malware_db import (
    MalwareDatabase, MalwareDBError
)


class TestMalwareDB(unittest.TestCase):

    def setUp(self):
        self.temp_dir = tempfile.mkdtemp()
        self.config_dict = {
            "schema_version": 1,
            "mode": "cloud",
            "cloud_malware_url": "",  # we'll set it if we want cloud
        }
        self.cfg = SentinelConfig(self.config_dict)
        self.db = MalwareDatabase(self.cfg)
        self.db.local_path = os.path.join(self.temp_dir, "malware_signatures.json")

    def tearDown(self):
        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def _write_local_signatures(self, data: dict):
        with open(self.db.local_path, "w", encoding="utf-8") as f:
            json.dump(data, f)

    def test_load_local_scif(self):
        """
        If mode=scif => no network call, just local
        """
        self.cfg.raw_dict["mode"] = "scif"
        # write local file
        sig_data = {
            "hashes": {
                "aaaabbbb": "TestThreat"
            }
        }
        self._write_local_signatures(sig_data)
        self.db.load_signatures()
        self.assertIn("aaaabbbb", self.db.hash_db)

    @patch("aepok_sentinel.utils.malware_db.requests.get")
    def test_load_cloud_success(self, mock_get):
        """
        mode=cloud, cloud_malware_url => fetch
        """
        self.cfg.raw_dict["cloud_malware_url"] = "https://fakecloud/malware.json"
        mock_resp = MagicMock()
        mock_resp.status_code = 200
        mock_resp.json.return_value = {
            "hashes": {
                "abc123": "FakeMalware"
            }
        }
        mock_get.return_value = mock_resp

        self.db.load_signatures()
        self.assertIn("abc123", self.db.hash_db)
        self.assertEqual(self.db.hash_db["abc123"], "FakeMalware")

    @patch("aepok_sentinel.utils.malware_db.requests.get")
    def test_load_cloud_failure_fallback_local(self, mock_get):
        """
        If cloud fetch fails => fallback to local
        """
        self.cfg.raw_dict["cloud_malware_url"] = "https://fakecloud/malware.json"
        mock_resp = MagicMock()
        mock_resp.status_code = 404
        mock_get.return_value = mock_resp

        sig_data = {
            "hashes": {
                "localhash": "LocalThreat"
            }
        }
        self._write_local_signatures(sig_data)

        self.db.load_signatures()
        self.assertIn("localhash", self.db.hash_db)

    def test_no_local_file(self):
        """
        If no local file => empty DB
        """
        self.db.load_signatures()
        self.assertEqual(len(self.db.hash_db), 0)

    def test_invalid_local_file(self):
        """
        If local file invalid => raises MalwareDBError
        """
        with open(self.db.local_path, "w", encoding="utf-8") as f:
            f.write("not valid json")
        with self.assertRaises(MalwareDBError):
            self.db.load_signatures()

    def test_check_file_match(self):
        """
        If hash in db => returns threat name
        """
        sig_data = {
            "hashes": {
                # We'll create a file and compute its sha256
                # but let's do it manually for demonstration
            }
        }
        path = os.path.join(self.temp_dir, "testfile.bin")
        with open(path, "wb") as f:
            f.write(b"HelloMalware")

        import hashlib
        sha = hashlib.sha256(b"HelloMalware").hexdigest()
        sig_data["hashes"][sha] = "BadStuff"

        self._write_local_signatures(sig_data)
        self.db.load_signatures()

        threat = self.db.check_file(path)
        self.assertEqual(threat, "BadStuff")

    def test_check_file_no_match(self):
        path = os.path.join(self.temp_dir, "testfile.bin")
        with open(path, "wb") as f:
            f.write(b"HelloMalware")

        # no local sigs => empty
        self.db.load_signatures()
        threat = self.db.check_file(path)
        self.assertIsNone(threat)


if __name__ == "__main__":
    unittest.main()