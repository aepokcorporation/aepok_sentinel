"""
Unit tests for aepok_sentinel/utils/malware_db.py (Final Shape)

Covers:
 - scif/airgap => local only
 - cloud => PQC-based fetch or fallback
 - directory_contract usage for local path
 - check_file => threat match
 - error handling
"""

import unittest
import os
import json
import shutil
import tempfile
from unittest.mock import patch, MagicMock

from aepok_sentinel.core.config import SentinelConfig
from aepok_sentinel.utils.malware_db import MalwareDatabase, MalwareDBError


@patch("aepok_sentinel.core.directory_contract.resolve_path")
class TestMalwareDB(unittest.TestCase):

    def setUp(self):
        self.temp_dir = tempfile.mkdtemp()
        self.config_dict = {
            "schema_version": 1,
            "mode": "cloud",
            "tls_mode": "hybrid",
            "strict_transport": False,
            "cloud_malware_url": ""
        }
        self.cfg = SentinelConfig(self.config_dict)

    def tearDown(self):
        shutil.rmtree(self.temp_dir, ignore_errors=True)

    def _write_json(self, path_obj, data: dict):
        path_str = str(path_obj)
        with open(path_str, "w", encoding="utf-8") as f:
            json.dump(data, f)

    def test_scif_no_fetch_local_only(self, mock_resolve):
        self.cfg.raw_dict["mode"] = "scif"
        fake_path = os.path.join(self.temp_dir, "malware_signatures.json")
        mock_resolve.return_value = fake_path

        # Write local file
        data = {
            "hashes": {"abc123": "FakeThreat"}
        }
        self._write_json(fake_path, data)

        db = MalwareDatabase(self.cfg)
        db.load_signatures()
        self.assertIn("abc123", db.hash_db)

    @patch("aepok_sentinel.utils.malware_db.requests.get")
    def test_cloud_fetch_success(self, mock_get, mock_resolve):
        # mode=cloud, cloud_malware_url => fetch
        self.cfg.raw_dict["cloud_malware_url"] = "https://cloud.example/signatures.json"
        fake_path = os.path.join(self.temp_dir, "local_malware_signatures.json")
        mock_resolve.return_value = fake_path

        db = MalwareDatabase(self.cfg)
        mock_resp = MagicMock()
        mock_resp.status_code = 200
        mock_resp.json.return_value = {
            "hashes": {"xyz999": "CloudThreat"}
        }
        mock_get.return_value = mock_resp

        db.load_signatures()
        self.assertIn("xyz999", db.hash_db)
        self.assertEqual(db.hash_db["xyz999"], "CloudThreat")

    @patch("aepok_sentinel.utils.malware_db.requests.get")
    def test_cloud_fetch_fail_fallback_local(self, mock_get, mock_resolve):
        self.cfg.raw_dict["cloud_malware_url"] = "https://cloud.example/signatures.json"
        fake_path = os.path.join(self.temp_dir, "local_malware.json")
        mock_resolve.return_value = fake_path

        # local file
        self._write_json(fake_path, {"hashes": {"localhash": "LocalThreat"}})

        # mock 404
        mock_resp = MagicMock()
        mock_resp.status_code = 404
        mock_get.return_value = mock_resp

        db = MalwareDatabase(self.cfg)
        db.load_signatures()
        # fallback => local => localhash
        self.assertIn("localhash", db.hash_db)

    def test_local_file_invalid(self, mock_resolve):
        fake_path = os.path.join(self.temp_dir, "sig.json")
        mock_resolve.return_value = fake_path
        with open(fake_path, "w", encoding="utf-8") as f:
            f.write("not valid json")

        db = MalwareDatabase(self.cfg)
        with self.assertRaises(MalwareDBError):
            db.load_signatures()

    def test_no_local_file(self, mock_resolve):
        # no file => empty db
        mock_resolve.return_value = os.path.join(self.temp_dir, "nonexistent.json")
        db = MalwareDatabase(self.cfg)
        db.load_signatures()
        self.assertEqual(len(db.hash_db), 0)

    def test_check_file_match(self, mock_resolve):
        # create local sig with known hash
        fake_path = os.path.join(self.temp_dir, "sigs.json")
        mock_resolve.return_value = fake_path

        test_file = os.path.join(self.temp_dir, "test.bin")
        with open(test_file, "wb") as f:
            f.write(b"someMalwareTest")

        import hashlib
        sha_val = hashlib.sha256(b"someMalwareTest").hexdigest()

        sig_data = {"hashes": {sha_val: "MaliciousSample"}}
        self._write_json(fake_path, sig_data)

        db = MalwareDatabase(self.cfg)
        db.load_signatures()
        threat = db.check_file(test_file)
        self.assertEqual(threat, "MaliciousSample")

    def test_check_file_noexist(self, mock_resolve):
        fake_path = os.path.join(self.temp_dir, "sigs.json")
        mock_resolve.return_value = fake_path
        db = MalwareDatabase(self.cfg)
        db.load_signatures()
        threat = db.check_file("/path/does/not/exist.bin")
        self.assertIsNone(threat)


if __name__ == "__main__":
    unittest.main()