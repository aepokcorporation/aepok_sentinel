"""
Step 5.3: Malware Database Utility

Provides:
  - MalwareDatabase class to manage local or cloud-based malware signatures (hash denies, YARA patterns, etc.).
  - load_signatures() from a local JSON file or optional cloud fetch if mode=cloud and scif/airgap is not active.
  - check_file(filepath) => returns a threat name if matched, else None.

No references to future steps (audit chain, daemon). The security_daemon in Step 7 will invoke this.

Complies with final-shape, no placeholders.
"""

import os
import json
import hashlib
import logging
import requests
from typing import Dict, Optional

from aepok_sentinel.core.logging_setup import get_logger
from aepok_sentinel.core.config import SentinelConfig

logger = get_logger("malware_db")


class MalwareDBError(Exception):
    """Raised on any malware DB load/fetch error."""


class MalwareDatabase:
    """
    Manages a collection of known-malicious signatures (file hashes, YARA rules, etc.).
    Basic approach:
      - load local JSON from 'malware_signatures.json' or config-defined path
      - if mode=cloud => optionally fetch updates from a cloud endpoint
      - scif/airgap => no fetch
      - check_file() => returns threat name if match, else None
    """

    def __init__(self, config: SentinelConfig):
        self.config = config
        self.local_path = os.path.join("/etc/sentinel", "malware_signatures.json")  # default
        # We'll store a simple dict mapping "sha256_hash -> threat_name"
        self.hash_db: Dict[str, str] = {}
        # Future expansions: YARA, etc. For final shape, we do the hash approach.

    def load_signatures(self) -> None:
        """
        Loads signatures from local JSON, or tries a cloud fetch if config says so.
        """
        # If scif/airgap => no network call
        if self.config.mode in ("scif", "airgap"):
            # Just load local
            self._load_local()
            return

        # If mode=cloud => check if we want to fetch from a cloud endpoint
        # We'll do a minimal "cloud_malware_url" or something in config
        cloud_malware_url = self.config.raw_dict.get("cloud_malware_url", "")
        if self.config.mode == "cloud" and cloud_malware_url:
            try:
                # fetch from cloud
                self._fetch_cloud_signatures(cloud_malware_url)
                logger.info("Fetched malware signatures from cloud: %s", cloud_malware_url)
            except Exception as e:
                logger.warning("Cloud fetch failed: %s, fallback to local load", e)
                self._load_local()
        else:
            # fallback to local
            self._load_local()

    def check_file(self, filepath: str) -> Optional[str]:
        """
        Checks if a file matches any known malicious hash in our DB.
        Returns the 'threat name' if matched, else None.
        """
        if not os.path.isfile(filepath):
            logger.warning("check_file: path does not exist: %s", filepath)
            return None

        try:
            sha_val = self._compute_sha256(filepath)
        except Exception as e:
            logger.warning("Failed to compute hash for %s: %s", filepath, e)
            return None

        return self.hash_db.get(sha_val)

    # ---------------- Private Methods ----------------

    def _load_local(self) -> None:
        """
        Loads local malware_signatures.json from self.local_path, populates self.hash_db
        If file doesn't exist, we proceed with an empty DB.
        """
        if not os.path.isfile(self.local_path):
            logger.info("No local malware signature file found at %s, using empty DB.", self.local_path)
            return
        try:
            with open(self.local_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            if not isinstance(data, dict):
                raise ValueError("malware_signatures.json is not a dict structure.")
            # we expect data["hashes"] to be a dict {sha256: threat_name}
            # but let's handle it gracefully
            hash_dict = data.get("hashes", {})
            if not isinstance(hash_dict, dict):
                raise ValueError("No 'hashes' dict found or invalid in local signature file.")
            self.hash_db = {**hash_dict}
            logger.info("Loaded %d malicious hashes from %s", len(self.hash_db), self.local_path)
        except Exception as e:
            msg = f"Failed to load local signatures from {self.local_path}: {e}"
            logger.error(msg)
            raise MalwareDBError(msg)

    def _fetch_cloud_signatures(self, url: str) -> None:
        """
        Minimal fetch from a cloud endpoint returning JSON:
          {
            "hashes": {
              "deadbeef...": "Trojan.WinXYZ",
              ...
            }
          }
        If fails => raise or fallback to local.
        """
        try:
            resp = requests.get(url, timeout=10)
            if resp.status_code != 200:
                raise MalwareDBError(f"Cloud signature fetch returned {resp.status_code}")
            data = resp.json()
            hash_dict = data.get("hashes", {})
            if not isinstance(hash_dict, dict):
                raise MalwareDBError("Cloud signature JSON missing 'hashes' dict")
            self.hash_db = {**hash_dict}
        except Exception as e:
            raise MalwareDBError(f"Cloud fetch error: {e}")

    def _compute_sha256(self, filepath: str) -> str:
        sha = hashlib.sha256()
        with open(filepath, "rb") as f:
            for chunk in iter(lambda: f.read(65536), b""):
                sha.update(chunk)
        return sha.hexdigest()